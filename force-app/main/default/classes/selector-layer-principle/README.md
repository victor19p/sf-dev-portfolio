# Selector Layer Implementation Exercise

## Overview
This exercise implements a basic Selector class following the Selector Layer pattern using the Apex Common library's `fflib_SObjectSelector` framework. The Selector pattern provides a centralized and standardized way to query data from Salesforce objects.

## Objective
Implement a Selector class that demonstrates:
- Data access layer separation using enterprise patterns
- Standardized query methods for Account objects
- Proper field selection and type safety
- Integration with fflib enterprise architecture

## Prerequisites
Before starting this exercise, ensure the following open source library is deployed:
- **Apex Common (fflib)** - For the SObjectSelector framework

## Implementation Details

### Selector Class: `AccountsSelector.cls`
**Location:** `force-app/main/default/classes/selector-layer-principle/AccountsSelector.cls`

The selector class extends `fflib_SObjectSelector` and provides standardized data access methods for Account objects.

#### Key Components:

##### 1. `getSObjectFieldList()`
**Purpose**: Defines which fields should be included in all queries generated by this selector.

**Fields Configured**:
- `Account.ID` - Standard Salesforce record identifier
- `Account.Description` - Custom description field
- `Account.Name` - Standard account name field  
- `Account.AnnualRevenue` - Standard financial field

**Benefits**:
- **Consistency**: All queries through this selector include the same base fields
- **Performance**: Only required fields are queried, reducing data transfer
- **Maintainability**: Field list is centralized and easy to modify

##### 2. `getSObjectType()`
**Purpose**: Specifies the SObject type this selector operates on.

**Implementation**: Returns `Account.sObjectType` to indicate this selector works with Account records.

**Benefits**:
- **Type Safety**: Ensures the selector only works with Account objects
- **Framework Integration**: Enables fflib framework features and validations

##### 3. `selectById(Set<ID> idSet)`
**Purpose**: Provides a standard method to query Account records by their IDs.

**Parameters**: 
- `idSet` - A set of Account record IDs to query

**Returns**: 
- `List<Account>` - List of Account records matching the provided IDs

**Implementation**: 
- Delegates to the inherited `selectSObjectsById()` method from fflib_SObjectSelector
- Automatically includes all fields defined in `getSObjectFieldList()`
- Returns properly typed List<Account> instead of generic List<SObject>

## How It Works

### Query Generation Flow:
1. **Method Call**: `selectById(Set<ID> idSet)` is called with a set of Account IDs
2. **Field Selection**: Automatically includes fields from `getSObjectFieldList()`
3. **Query Construction**: fflib framework builds the SOQL query
4. **Execution**: Query is executed against the Account object
5. **Type Casting**: Results are cast to `List<Account>` for type safety
6. **Return**: Typed list of Account records is returned

### Generated SOQL Example:
```sql
SELECT Id, Description, Name, AnnualRevenue 
FROM Account 
WHERE Id IN :idSet
```

## Benefits of This Pattern

### 1. **Separation of Concerns**
- Data access logic is centralized in Selector classes
- Business logic classes don't contain SOQL queries
- Clear boundaries between data access and business rules

### 2. **Consistency**
- Standardized field selection across all queries
- Consistent naming conventions for query methods
- Uniform error handling and query optimization

### 3. **Maintainability**
- Field changes are managed in one location
- Easy to add new query methods
- Centralized query logic reduces code duplication

### 4. **Performance**
- Optimized field selection (only necessary fields)
- Bulk query support through Set<ID> parameters
- Framework-level query optimizations

### 5. **Type Safety**
- Strongly typed return values
- Compile-time checking for field access
- Reduced runtime errors from incorrect casting

### 6. **Testability**
- Selector can be mocked for unit testing
- Clear interface for data access operations
- Supports dependency injection patterns

## Usage Examples

### Basic Usage:
```apex
// Initialize the selector
AccountsSelector selector = new AccountsSelector();

// Create a set of Account IDs
Set<Id> accountIds = new Set<Id>{
    '001000000000001',
    '001000000000002',
    '001000000000003'
};

// Query accounts by ID
List<Account> accounts = selector.selectById(accountIds);

// Use the results
for (Account acc : accounts) {
    System.debug('Account Name: ' + acc.Name);
    System.debug('Description: ' + acc.Description);
    System.debug('Annual Revenue: ' + acc.AnnualRevenue);
}
```

### Integration with Domain Classes:
```apex
// In a Domain class or Service class
public class AccountService {
    private AccountsSelector accountsSelector;
    
    public AccountService() {
        this.accountsSelector = new AccountsSelector();
    }
    
    public List<Account> getAccountsForProcessing(Set<Id> accountIds) {
        return accountsSelector.selectById(accountIds);
    }
}
```

### Bulk Operations:
```apex
// Process multiple accounts efficiently
Set<Id> largeAccountIdSet = new Set<Id>();
// ... populate with many IDs

AccountsSelector selector = new AccountsSelector();
List<Account> accounts = selector.selectById(largeAccountIdSet);

// All accounts retrieved in a single query with consistent field set
```

## Enterprise Architecture Integration

### 1. **Application Factory Pattern**
```apex
// Can be registered with Application class for dependency injection
Application.Selector.selectById(accountIds);
```

### 2. **Unit of Work Pattern**
```apex
// Selectors provide data for Unit of Work operations
fflib_SObjectUnitOfWork uow = new fflib_SObjectUnitOfWork(...);
List<Account> accounts = selector.selectById(accountIds);
// ... modify accounts
uow.registerDirty(accounts);
```

### 3. **Service Layer Pattern**
```apex
// Services use Selectors for data access
public class AccountService {
    public void processAccounts(Set<Id> accountIds) {
        AccountsSelector selector = new AccountsSelector();
        List<Account> accounts = selector.selectById(accountIds);
        // ... business logic
    }
}
```

## Best Practices Demonstrated

### 1. **Consistent Field Selection**
- All queries include the same base fields
- Prevents field-level security errors
- Optimizes query performance

### 2. **Bulk Operation Support**
- Methods accept collections (Set<Id>) rather than single values
- Supports efficient bulk processing
- Prevents governor limit issues

### 3. **Type Safety**
- Return strongly typed collections
- Eliminate casting errors
- Provide better IDE support and intellisense

### 4. **Extensibility**
- Easy to add new query methods
- Can override base functionality when needed
- Supports complex query requirements

## Extending the Selector

### Adding Custom Query Methods:
```apex
public class AccountsSelector extends fflib_SObjectSelector {
    // ... existing methods
    
    public List<Account> selectByName(Set<String> names) {
        return (List<Account>) Database.query(
            newQueryFactory()
                .setCondition('Name IN :names')
                .toSOQL()
        );
    }
    
    public List<Account> selectByAnnualRevenue(Decimal minRevenue) {
        return (List<Account>) Database.query(
            newQueryFactory()
                .setCondition('AnnualRevenue >= :minRevenue')
                .toSOQL()
        );
    }
}
```

## Key Learning Points

1. **Data Access Patterns**: Centralized query logic improves maintainability
2. **Framework Integration**: Leveraging established frameworks reduces custom code
3. **Type Safety**: Strongly typed interfaces prevent runtime errors
4. **Performance**: Consistent field selection and bulk operations optimize queries
5. **Enterprise Architecture**: Selector pattern enables clean separation of concerns
6. **Scalability**: Pattern supports complex applications with multiple data access needs

## File Structure
```
force-app/main/default/classes/selector-layer-principle/
├── AccountsSelector.cls           # Selector class implementation
└── AccountsSelector.cls-meta.xml  # Metadata file
```

## Next Steps
- Add unit tests for the AccountsSelector class
- Implement additional query methods for common use cases
- Create selectors for related objects
- Integrate with Service and Domain layers
- Add complex query methods with joins and relationships
- Implement caching strategies for frequently accessed data

## Related Patterns
- **Domain Layer**: Uses Selectors for data retrieval in business logic
- **Service Layer**: Orchestrates multiple Selectors and Domains
- **Unit of Work**: Manages data modifications retrieved by Selectors
- **Application Factory**: Provides dependency injection for Selectors
